<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Fate Walkers - Tactics</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: white; font-family: 'Pretendard', sans-serif;
            margin: 0; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            min-height: 100vh; overflow: hidden; user-select: none;
        }

        #lobby-screen, #char-select-screen {
            text-align: center; background: rgba(0, 0, 0, 0.9);
            padding: 40px; border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: absolute; z-index: 20;
        }

        #char-select-screen { display: none; width: 900px; max-height: 95vh; overflow-y: auto; }
        
        h1 { font-size: 3rem; margin-bottom: 20px; color: #00c6ff; }

        button {
            padding: 15px 40px; font-size: 1.2rem; font-weight: bold; color: white;
            border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
        }
        #find-match-btn { background: linear-gradient(45deg, #ff416c, #ff4b2b); }
        #lock-in-btn { background: #0072ff; }
        #lock-in-btn:disabled { background: #555; cursor: not-allowed; }

        #char-grid { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        
        #char-info-box {
            background: rgba(30, 30, 30, 0.95); border: 2px solid #00c6ff;
            color: #eee; padding: 20px; border-radius: 10px;
            min-height: 150px; width: 100%; box-sizing: border-box; 
            text-align: left; font-size: 1rem; line-height: 1.6;
        }
        
        /* 게임 화면 */
        #game-container { 
            display: none; 
            border: 2px solid #555; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); 
            border-radius: 10px;
            background-color: #1a1a1a;
            width: 800px; height: 800px; /* 크기 고정 */
        }
    </style>
</head>
<body>

    <div id="lobby-screen">
        <h1>Fate Walkers</h1>
        <p>전략 턴제 배틀</p>
        <button id="find-match-btn">매칭 시작</button>
    </div>

    <div id="char-select-screen">
        <h2>영웅 선택</h2>
        <div id="char-grid"></div>
        <div id="char-info-box">캐릭터에 마우스를 올리면 정보가 표시됩니다.</div>
        <button id="lock-in-btn" disabled>선택 완료</button>
    </div>

    <div id="game-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, get, set, update, push, onValue } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

        // =========================================================
        // ★★★ Firebase 키 입력 (필수) ★★★
        // =========================================================
        const firebaseConfig = {
  apiKey: "AIzaSyCMtMnUbfeeLTSFZJuRhDkv5xoCi2ioS6M",
  authDomain: "fatewalkers-29335.firebaseapp.com",
  databaseURL: "https://fatewalkers-29335-default-rtdb.firebaseio.com",
  projectId: "fatewalkers-29335",
  storageBucket: "fatewalkers-29335.firebasestorage.app",
  messagingSenderId: "343677807456",
  appId: "1:343677807456:web:c2b4a7bde3b9284b5c8c05",
  measurementId: "G-RVRS4BGZD1"
};
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ==========================================
        // [데이터] 캐릭터 및 스킬
        // ==========================================
        const DB = {
            SKILLS: {
                SLASH: { name: "베기", power: 25, range: 3, cooldown: 0, cost: 0, desc: "사거리 3칸, 데미지 25" },
                UPPER_SLASH: { name: "상단 베기", power: 50, range: 2, cooldown: 3, cost: 0, desc: "강력한 일격 (쿨타임 3)" },
                GUARD: { name: "가드", type: "buff", cooldown: 2, reduction: 0.3, cost: 0, desc: "다음 피해 30% 경감" },
                SHIELD_THROW: { name: "방패 던지기", power: 10, range: 4, triggerReAction: true, isUltimate: true, cost: 0, desc: "[궁극기] 1회용. 사용 후 재행동." },
                MAGIC_MISSILE: { name: "매직미사일", power: 20, range: 5, cost: 10, cooldown: 0, desc: "MP 10 소모" },
                FIREBALL: { name: "파이어볼", power: 30, range: 5, cost: 20, cooldown: 2, desc: "화염구 (MP 20)" },
                ICE_SPEAR: { name: "아이스 스피어", power: 35, range: 4, cost: 20, cooldown: 2, desc: "얼음창 (MP 20)" },
                INFERNITY: { name: "인페르니티", power: 110, range: 8, cost: 100, cooldown: 5, isUltimate: true, disablePassive: 1, desc: "[궁극기] MP 100, 패시브 봉인" },
                DIAGONAL_SLASH: { name: "사선베기", power: 25, range: 2, cooldown: 0, cost: 0, extraMove: 3, desc: "공격 후 3칸 이동" },
                STEALTH: { name: "은신", type: "buff", range: 0, cooldown: 4, cost: 0, triggerReAction: true, effect: "stealth", desc: "은신(이동+1) & 재행동" },
                KUNAI_THROW: { name: "쿠나이 던지기", power: 25, range: 4, cooldown: 0, cost: 0, extraMove: 3, desc: "원거리 견제" },
                BACKSTAB: { name: "배후노리기", power: 60, range: 6, cooldown: 0, cost: 0, isUltimate: true, reqStealth: true, teleportBehind: true, extraMove: 1, desc: "[궁극기] 은신 필수. 적 배후 이동" },
                SNIPE: { name: "저격", power: 20, range: 6, minRange: 4, cooldown: 0, cost: 0, desc: "사거리 4-6. 조준 시 강화" },
                AIM: { name: "조준", type: "buff", range: 0, cooldown: 0, cost: 0, triggerReAction: true, effect: "aim", desc: "이동불가, 저격 강화, 재행동" },
                BACKSTEP: { name: "백스텝", power: 0, range: 0, cooldown: 2, cost: 0, triggerReAction: true, effect: "backstep", desc: "뒤로 2칸 이동 & 재행동" },
                HEADSHOT: { name: "헤드샷", power: 70, range: 7, minRange: 5, cooldown: 6, cost: 0, isUltimate: true, chargeTurn: 1, desc: "[궁극기] 1턴 차징 후 발사" },
                DAGGER_STAB: { name: "단검 찌르기", power: 20, range: 2, cooldown: 0, cost: 0, desc: "기본 공격" },
                PATH_DETECT: { name: "경로 탐지", type: "buff", range: 0, cooldown: 2, cost: 0, effect: "path_detect", desc: "3배수:기습3배 / 2배수:단검+10" },
                PATH_SET: { name: "경로 설정", type: "buff", range: 0, cooldown: 4, cost: 0, triggerReAction: true, effect: "path_set", desc: "거리10이상 시 이동+7 & 재행동" },
                CROSSBOW_SURGE: { name: "석궁 쇄도", power: 0, range: 5, cooldown: 4, cost: 0, isUltimate: true, desc: "[궁극기] 기습(11칸)시 사용가능" }
            },
            PASSIVES: {
                KNIGHT_SHIELD: { name: "기사의 방패", desc: "30%확률로 데미지 20% 경감" },
                MANA_MASTER: { name: "마나의 주인", desc: "매 턴 MP 30 회복" },
                STEALTH_ART: { name: "은신술", desc: "은신 시 이동력 +1" },
                CRITICAL_HIT: { name: "크리티컬 히트", desc: "5% 확률로 1.5배 데미지" },
                PATHFINDER_KIT: { name: "패스파인더 키트", desc: "기습(11칸이상 2배), 화살줍기(4칸당+1)" }
            },
            CHARACTERS: {
                KNIGHT: { name: "기사", hp: 120, mp: 0, move: [3, 4], skills: ["SLASH", "UPPER_SLASH", "GUARD", "SHIELD_THROW"], passive: "KNIGHT_SHIELD", color: '#C0C0C0', desc: "높은 체력과 방어력 (탱커)" },
                MAGE: { name: "마법사", hp: 100, mp: 100, move: [2, 4], skills: ["MAGIC_MISSILE", "FIREBALL", "ICE_SPEAR", "INFERNITY"], passive: "MANA_MASTER", color: '#9C27B0', desc: "강력한 마법 공격 (누커)" },
                NINJA: { name: "닌자", hp: 85, mp: 0, move: [4, 5], skills: ["DIAGONAL_SLASH", "STEALTH", "KUNAI_THROW", "BACKSTAB"], passive: "STEALTH_ART", color: '#333333', desc: "은신과 암살 (암살자)" },
                BOW_MASTER: { name: "보우 마스터", hp: 100, mp: 0, move: [3, 4], skills: ["SNIPE", "AIM", "BACKSTEP", "HEADSHOT"], passive: "CRITICAL_HIT", color: '#228B22', desc: "초장거리 저격 (스나이퍼)" },
                PATHFINDER: { name: "패스파인더", hp: 70, mp: 0, move: [4, 7], skills: ["DAGGER_STAB", "PATH_DETECT", "PATH_SET", "CROSSBOW_SURGE"], passive: "PATHFINDER_KIT", color: '#FF4500', desc: "기동성과 거리 비례 딜 (레인저)" }
            }
        };

        const PIXEL_DATA = {
            knight: { colors: {'s':'#C0C0C0','f':'#FFCC99','r':'#FF0000','b':'#4169E1'}, data: ["  ssss  "," ssrrss "," ssssss ","  ffff  ","  bbbb  "," ggssgg ","  s  s  "] },
            mage: { colors: {'p':'#800080','f':'#FFCC99','y':'#FFD700'}, data: ["  pppp  "," pppppp ","  ffff  ","  pppp  "," yppppppy","  p  p  "] },
            ninja: { colors: {'k':'#1a1a1a','r':'#8b0000','s':'#fff'}, data: ["  kkkk  "," kkkkkk "," kskksk ","  ffff  ","  kkkk  "," krrkkr ","  k  k  "] },
            bowmaster: { colors: {'g':'#2E7D32','b':'#8B4513','f':'#FFCC99'}, data: ["  gggg  "," ggggb b","  ffff  ","  gggg  "," bgggggb","  g  g  "] },
            pathfinder: { colors: {'o':'#FF4500','b':'#444','f':'#FFCC99'}, data: ["  oooo  "," oooooo ","  ffff  ","  bbbb  "," obbbbo ","  b  b  "] }
        };

        // ==========================================
        // [게임 설정 변수]
        // ==========================================
        const GRID_W = 11;
        const GRID_H = 7;
        const TILE_SIZE = 60;
        const SCREEN_W = 800;
        const SCREEN_H = 800;
        
        // 맵을 화면 중앙에 배치하기 위한 시작점 계산
        const OFFSET_X = (SCREEN_W - (GRID_W * TILE_SIZE)) / 2; // (800 - 660)/2 = 70
        const OFFSET_Y = (SCREEN_H - (GRID_H * TILE_SIZE)) / 2; // (800 - 420)/2 = 190

        let myRole = null, currentRoomId = null, isMyTurn = false;
        let selectedCharKey = null, game = null;
        let mapData = [];
        let playerUnit, enemyUnit, hudText, descText, actionMenu;
        let gameState = 0; // 0:IDLE, 1:MOVE, 2:ACTION, 3:TARGET, 4:BUSY
        let validMoves = []; // 이동 가능한 좌표 목록 [{x,y}, ...]

        // ==========================================
        // [좌표 시스템] - 여기가 제일 중요!
        // ==========================================
        
        // 1. 화면(픽셀) -> 그리드(x,y) 변환
        function pixelToGrid(px, py) {
            const gx = Math.floor((px - OFFSET_X) / TILE_SIZE);
            const gy = Math.floor((py - OFFSET_Y) / TILE_SIZE);
            return { x: gx, y: gy };
        }

        // 2. 그리드(x,y) -> 화면(픽셀) 변환 (타일 중앙)
        function gridToPixel(gx, gy) {
            return {
                x: OFFSET_X + (gx * TILE_SIZE) + (TILE_SIZE / 2),
                y: OFFSET_Y + (gy * TILE_SIZE) + (TILE_SIZE / 2)
            };
        }

        // 3. 로컬(내화면) <-> 서버(DB) 변환
        // P2는 맵을 180도 뒤집어서 봄. (0,0)이 서버의 (10,6)이 됨.
        function toServer(lx, ly) {
            if (myRole === 'p2') return { x: (GRID_W - 1) - lx, y: (GRID_H - 1) - ly };
            return { x: lx, y: ly };
        }
        function toLocal(sx, sy) {
            if (myRole === 'p2') return { x: (GRID_W - 1) - sx, y: (GRID_H - 1) - sy };
            return { x: sx, y: sy };
        }

        // ==========================================
        // [매칭 시스템]
        // ==========================================
        document.getElementById('find-match-btn').onclick = () => {
            const btn = document.getElementById('find-match-btn');
            btn.disabled = true; btn.innerText = "매칭 중...";
            get(ref(db, 'rooms')).then((snap) => {
                const rooms = snap.val(); let found = null;
                if (rooms) for (let id in rooms) if (rooms[id].status === 'waiting') { found = id; break; }
                if (found) joinRoom(found); else createRoom();
            }).catch(e => { console.error(e); alert("DB 연결 실패!"); btn.disabled=false; });
        };

        function createRoom() {
            const newRef = push(ref(db, 'rooms'));
            currentRoomId = newRef.key; myRole = 'p1';
            const map = generateMap();
            set(newRef, { status: 'waiting', turn: 'p1', map: map, p1Ready: false, p2Ready: false });
            onValue(newRef, (s) => { if (s.val()?.status === 'selecting') onMatchFound(); });
        }

        function joinRoom(id) {
            currentRoomId = id; myRole = 'p2';
            update(ref(db, `rooms/${id}`), { status: 'selecting' });
            onMatchFound();
        }

        function onMatchFound() {
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('char-select-screen').style.display = 'flex';
            renderCharSelect();
        }

        function renderCharSelect() {
            const grid = document.getElementById('char-grid');
            grid.innerHTML = '';
            const infoBox = document.getElementById('char-info-box');
            
            Object.keys(DB.CHARACTERS).forEach(k => {
                const c = DB.CHARACTERS[k];
                const artKey = k.toLowerCase().replace('master', 'master');
                const iconData = PIXEL_DATA[artKey] || PIXEL_DATA['knight'];
                const iconUrl = drawIcon(iconData.data, iconData.colors);

                const el = document.createElement('div');
                el.style.cssText = `width:100px; height:120px; background:${c.color}; border:2px solid #fff; cursor:pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; box-shadow: 0 0 10px rgba(0,0,0,0.5);`;
                el.innerHTML = `<img src="${iconUrl}" style="width:64px; height:64px; image-rendering:pixelated; margin-bottom:5px;"><b>${c.name}</b>`;
                
                el.onmouseenter = () => {
                    let skillHtml = `<div class='skill-list'>`;
                    c.skills.forEach(sid => {
                        const s = DB.SKILLS[sid];
                        skillHtml += `<div class='skill-item'><span class='skill-name'>${s.name}</span><br><span style='font-size:0.8rem; color:#bbb;'>${s.desc}</span></div>`;
                    });
                    skillHtml += `</div>`;
                    const passive = DB.PASSIVES[c.passive];
                    infoBox.innerHTML = `
                        <div class='info-title' style='color:${c.color}'>${c.name}</div>
                        <div class='info-desc'>${c.desc}</div>
                        <div><b>이동력:</b> ${c.move[0]}~${c.move[1]}칸 &nbsp;|&nbsp; <b>체력:</b> ${c.hp}</div>
                        <div class='passive-item'>[패시브] ${passive.name}: ${passive.desc}</div>
                        <br><b>[보유 스킬]</b> ${skillHtml}
                    `;
                };

                el.onclick = () => {
                    Array.from(grid.children).forEach(b => b.style.border = "2px solid #fff");
                    el.style.border = "4px solid yellow";
                    selectedCharKey = k;
                    update(ref(db, `rooms/${currentRoomId}`), { [`${myRole}Char`]: k });
                    document.getElementById('lock-in-btn').disabled = false;
                };
                grid.appendChild(el);
            });

            const lockBtn = document.getElementById('lock-in-btn');
            const newLockBtn = lockBtn.cloneNode(true);
            lockBtn.parentNode.replaceChild(newLockBtn, lockBtn);
            
            newLockBtn.onclick = () => {
                update(ref(db, `rooms/${currentRoomId}`), { [`${myRole}Ready`]: true });
                newLockBtn.disabled = true; newLockBtn.innerText = "대기 중...";
            };
        }

        setInterval(() => {
            if (!currentRoomId) return;
            get(ref(db, `rooms/${currentRoomId}`)).then((snap) => {
                const d = snap.val(); if (!d) return;
                if (d.p1Ready && d.p2Ready && d.status !== 'playing') {
                    if (d.map) {
                        window.selectedChars = { p1: d.p1Char, p2: d.p2Char };
                        mapData = d.map;
                        if (myRole === 'p1') update(ref(db, `rooms/${currentRoomId}`), { status: 'playing' });
                        startGame();
                    }
                } 
                else if (d.status === 'playing' && !game) {
                     if (d.map) {
                        window.selectedChars = { p1: d.p1Char, p2: d.p2Char };
                        mapData = d.map;
                        startGame();
                     }
                }
            });
        }, 1500);

        function startGame() {
            if(game) return;
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('char-select-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            game = new Phaser.Game(config);
        }

        // ==========================================
        // [Phaser 로직] - 이동 로직 재작성
        // ==========================================
        class Unit {
            constructor(scene, data, lx, ly, isMe) {
                this.scene = scene;
                this.name = data.name; this.maxHp = data.hp; this.hp = data.hp; 
                this.mp = 0; this.maxMp = data.mp || 0;
                this.lx = lx; this.ly = ly; this.isMe = isMe;
                this.prevX = lx; this.prevY = ly;
                
                this.skills = data.skills.map(k => ({...DB.SKILLS[k], id: k}));
                this.passive = data.passive ? DB.PASSIVES[data.passive] : null;
                this.moveRange = data.move; this.cooldowns = {}; 
                
                // 상태 변수
                this.movedDistance = 0; this.arrows = 0;

                const pos = gridToPixel(lx, ly);
                let artKey = data.name === "보우 마스터" ? "bowmaster" : data.name.toLowerCase();
                if(!PIXEL_DATA[artKey]) artKey = "knight";

                // 캐릭터 클릭도 배경 클릭과 동일하게 처리 (이벤트 전파)
                this.sprite = scene.add.sprite(pos.x, pos.y, artKey + '_art').setScale(1.5).setDepth(10);
                if (!isMe) this.sprite.setTint(0xff8888);
                this.hpText = scene.add.text(pos.x, pos.y - 35, `${this.hp}`, { fontSize: '14px', fontStyle: 'bold' }).setOrigin(0.5).setDepth(11);
            }

            updatePos(lx, ly) {
                this.lx = lx; this.ly = ly;
                const pos = gridToPixel(lx, ly);
                this.sprite.x = pos.x; this.sprite.y = pos.y;
                this.hpText.x = pos.x; this.hpText.y = pos.y - 35;
            }
            savePos() { this.prevX = this.lx; this.prevY = this.ly; }
            revertPos() { this.updatePos(this.prevX, this.prevY); }
            takeDamage(d) { this.hp -= d; this.hpText.setText(`${this.hp}`); return this.hp <= 0; }
        }

        const config = {
            type: Phaser.AUTO, parent: 'game-container', width: SCREEN_W, height: SCREEN_H,
            backgroundColor: '#1a1a1a', scene: { preload: preload, create: create }
        };

        let highlights = [];

        function preload() {
            const createArt = (key, colors, pixels) => {
                const canvas = this.textures.createCanvas(key, 32, 32);
                const ctx = canvas.context;
                const size = 32 / pixels.length;
                for(let y=0; y<pixels.length; y++) for(let x=0; x<pixels[y].length; x++) {
                    if(pixels[y][x] !== ' ') { ctx.fillStyle = colors[pixels[y][x]]; ctx.fillRect(x*size, y*size, size, size); }
                }
                canvas.refresh();
            };
            Object.keys(PIXEL_DATA).forEach(k => createArt(k+'_art', PIXEL_DATA[k].colors, PIXEL_DATA[k].data));
        }

        function create() {
            if (!mapData || mapData.length === 0) return;

            // 1. 맵 그리기
            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    const sPos = toServer(x, y);
                    const cell = (mapData[sPos.x]) ? mapData[sPos.x][sPos.y] : null;
                    const type = cell ? cell.type : 'Grass';
                    
                    let color = type === 'Water' ? 0x1a4a7a : type === 'Mountain' ? 0x4a4a4a : type === 'Sand' ? 0x8a7a4a : 0x3d5e3a;
                    const pos = gridToPixel(x, y);
                    this.add.rectangle(pos.x, pos.y, TILE_SIZE-2, TILE_SIZE-2, color).setStrokeStyle(1, 0x000, 0.5);
                }
            }

            // 2. 유닛 생성 (P1은 (5,6) 고정)
            const myK = myRole === 'p1' ? window.selectedChars.p1 : window.selectedChars.p2;
            const enK = myRole === 'p1' ? window.selectedChars.p2 : window.selectedChars.p1;
            playerUnit = new Unit(this, DB.CHARACTERS[myK], 5, 6, true);
            enemyUnit = new Unit(this, DB.CHARACTERS[enK], 5, 0, false);

            // 3. UI
            hudText = this.add.text(400, 30, "대기 중...", { fontSize: '18px', align: 'center' }).setOrigin(0.5);
            descText = this.add.text(400, 750, "게임을 시작합니다.", { fontSize: '16px', align: 'center' }).setOrigin(0.5);
            actionMenu = this.add.container(680, 150).setDepth(100);

            // 4. 입력 처리 (배경 클릭이 아니라 화면 전체 클릭을 잡음)
            this.input.on('pointerdown', (pointer) => {
                const gridPos = pixelToGrid(pointer.x, pointer.y);
                
                // 범위 밖 클릭 무시
                if (gridPos.x < 0 || gridPos.x >= GRID_W || gridPos.y < 0 || gridPos.y >= GRID_H) return;
                
                processClick(gridPos.x, gridPos.y);
            });

            updateHUD();
            setupSync();
        }

        // ★★★ 핵심 로직: 좌표 기반 클릭 처리 ★★★
        function processClick(x, y) {
            console.log(`Clicked Grid: ${x}, ${y}, State: ${gameState}`);

            // 정보 표시
            if (x === playerUnit.lx && y === playerUnit.ly) descText.setText("내 캐릭터입니다.");
            else if (x === enemyUnit.lx && y === enemyUnit.ly) descText.setText("적 캐릭터입니다.");

            if (!isMyTurn || gameState === 4) return; // 4: BUSY

            // 1. 내 캐릭터 클릭 시 -> 이동 모드 시작
            if (gameState === 0 && x === playerUnit.lx && y === playerUnit.ly) {
                playerUnit.savePos();
                calculateMoveRange();
                gameState = 1; // MOVE_SELECT
                descText.setText("이동할 파란 칸을 클릭하세요.");
                return;
            }

            // 2. 이동 모드에서 파란 칸(유효한 좌표) 클릭 시 -> 이동
            if (gameState === 1) {
                // 클릭한 좌표(x,y)가 유효한 목록(validMoves)에 있는지 확인
                const isValid = validMoves.some(p => p.x === x && p.y === y);
                if (isValid) {
                    playerUnit.updatePos(x, y); // 이동
                    clearHighlights();
                    gameState = 2; // ACTION_WAIT
                    openActionMenu();
                    descText.setText("행동을 선택하세요.");
                } else {
                    // 엉뚱한 곳 누르면 취소
                    gameState = 0;
                    clearHighlights();
                    descText.setText("이동 취소됨.");
                }
                return;
            }
        }

        function calculateMoveRange() {
            validMoves = [];
            clearHighlights();
            
            const minMove = playerUnit.moveRange[0];
            const maxMove = playerUnit.moveRange[1];
            // 이번 턴은 랜덤으로 결정 (또는 고정) -> 여기선 랜덤 범위 적용
            const r = Phaser.Math.Between(minMove, maxMove); 
            console.log("Move Range:", r);

            for (let x = 0; x < GRID_W; x++) {
                for (let y = 0; y < GRID_H; y++) {
                    const dist = Math.abs(x - playerUnit.lx) + Math.abs(y - playerUnit.ly);
                    
                    // 사거리 체크
                    if (dist === 0 || dist > r) continue;

                    // 지형 체크 (서버 좌표 변환)
                    const sPos = toServer(x, y);
                    const cell = mapData[sPos.x] ? mapData[sPos.x][sPos.y] : null;
                    if (!cell) continue;
                    if (cell.type === 'Mountain' || cell.type === 'Water') continue;

                    // 적 유닛 체크
                    if (x === enemyUnit.lx && y === enemyUnit.ly) continue;

                    // 유효함 -> 목록에 추가하고 파란 칸 그리기
                    validMoves.push({x, y});
                    const pos = gridToPixel(x, y);
                    const rect = game.scene.scenes[0].add.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE, 0x0000ff, 0.4).setDepth(5);
                    highlights.push(rect);
                }
            }
        }

        function openActionMenu() {
            actionMenu.removeAll(true);
            let y = 0;
            const scene = game.scene.scenes[0];

            // 배경
            actionMenu.add(scene.add.rectangle(0, 100, 140, 300, 0x222222, 0.9));

            // 스킬 버튼들
            playerUnit.skills.forEach(skill => {
                const cd = playerUnit.cooldowns[skill.id] || 0;
                const btn = scene.add.rectangle(0, y, 120, 40, cd > 0 ? 0x555 : 0x880000).setInteractive();
                const txt = scene.add.text(0, y, skill.name + (cd?`(${cd})`:""), { fontSize:'14px' }).setOrigin(0.5);
                
                if (cd === 0) {
                    btn.on('pointerdown', () => {
                        // 스킬 사용 로직 (생략 없이 연결)
                        executeAction(skill, playerUnit); // 단순화: 일단 즉시 실행 (타겟팅 필요 시 추가 로직)
                    });
                }
                actionMenu.add(btn); actionMenu.add(txt); y += 50;
            });

            // 대기 버튼
            const waitBtn = scene.add.rectangle(0, y, 120, 40, 0x000088).setInteractive();
            const waitTxt = scene.add.text(0, y, "대기", { fontSize:'14px' }).setOrigin(0.5);
            waitBtn.on('pointerdown', () => executeAction({id:'WAIT'}, null));
            actionMenu.add(waitBtn); actionMenu.add(waitTxt);
        }

        function executeAction(skill, target) {
            gameState = 4; // BUSY
            actionMenu.removeAll(true);
            
            // 턴 종료 처리 및 서버 업데이트
            const sPos = toServer(playerUnit.lx, playerUnit.ly);
            update(ref(db, `rooms/${currentRoomId}`), {
                [`${myRole}Unit`]: { x: sPos.x, y: sPos.y, hp: playerUnit.hp },
                turn: myRole === 'p1' ? 'p2' : 'p1'
            });
        }

        function clearHighlights() { highlights.forEach(h => h.destroy()); highlights = []; }
        
        function updateHUD() {
            if(playerUnit && enemyUnit) {
                hudText.setText(`[나] HP:${playerUnit.hp}  vs  [적] HP:${enemyUnit.hp}`);
            }
        }

        function setupSync() {
            onValue(ref(db, `rooms/${currentRoomId}`), (snap) => {
                const d = snap.val(); if (!d) return;
                
                if (d.turn === myRole) {
                    isMyTurn = true; gameState = 0; descText.setText("나의 턴입니다!");
                } else {
                    isMyTurn = false; descText.setText("상대방의 턴...");
                }

                // 적 위치 동기화
                const enRole = myRole === 'p1' ? 'p2' : 'p1';
                const enD = d[`${enRole}Unit`];
                if (enD) {
                    const local = toLocal(enD.x, enD.y);
                    enemyUnit.updatePos(local.x, local.y);
                    enemyUnit.hp = enD.hp;
                }
                updateHUD();
            });
        }

        function drawIcon(pixels, colors) {
            const c = document.createElement('canvas'); c.width=32; c.height=32; const ctx=c.getContext('2d');
            const s=32/pixels.length;
            pixels.forEach((row, y) => [...row].forEach((col, x) => {
                if(col!==' ') { ctx.fillStyle=colors[col]; ctx.fillRect(x*s, y*s, s, s); }
            }));
            return c.toDataURL();
        }
        function generateMap() {
            let m = [];
            for(let x=0; x<GRID_W; x++) {
                m[x] = [];
                for(let y=0; y<GRID_H; y++) {
                    let t = 'Grass';
                    if(x!==5 && Math.random()<0.3) t=['Water','Mountain','Sand'][Math.floor(Math.random()*3)];
                    m[x][y] = {type: t};
                }
            }
            return m;
        }
    </script>
</body>
</html>
