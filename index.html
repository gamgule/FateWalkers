<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Fate Walkers - Tactics</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: white; font-family: 'Pretendard', sans-serif;
            margin: 0; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            min-height: 100vh; overflow: hidden; user-select: none;
        }

        #lobby-screen, #char-select-screen {
            text-align: center; background: rgba(0, 0, 0, 0.9);
            padding: 40px; border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: absolute; z-index: 20;
        }

        #char-select-screen { display: none; width: 900px; max-height: 95vh; overflow-y: auto; }
        
        h1 { font-size: 3rem; margin-bottom: 20px; color: #00c6ff; }

        button {
            padding: 15px 40px; font-size: 1.2rem; font-weight: bold; color: white;
            border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
        }
        #find-match-btn { background: linear-gradient(45deg, #ff416c, #ff4b2b); }
        #lock-in-btn { background: #0072ff; }
        #lock-in-btn:disabled { background: #555; cursor: not-allowed; }

        #char-grid { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        
        #char-info-box {
            background: rgba(30, 30, 30, 0.95); border: 2px solid #00c6ff;
            color: #eee; padding: 20px; border-radius: 10px;
            min-height: 200px; width: 100%; box-sizing: border-box; 
            text-align: left; font-size: 1rem; line-height: 1.6;
        }
        
        #game-container { 
            display: none; border: 4px solid #555; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8); 
            border-radius: 10px; background-color: #1a1a1a;
            width: 800px; height: 800px;
        }
    </style>
</head>
<body>

    <div id="lobby-screen">
        <h1>Fate Walkers</h1>
        <p>ì „ëµ í„´ì œ ë°°í‹€</p>
        <button id="find-match-btn">ë§¤ì¹­ ì‹œì‘</button>
    </div>

    <div id="char-select-screen">
        <h2>ì˜ì›… ì„ íƒ</h2>
        <div id="char-grid"></div>
        <div id="char-info-box">ìºë¦­í„°ì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤.</div>
        <button id="lock-in-btn" disabled>ì„ íƒ ì™„ë£Œ</button>
    </div>

    <div id="game-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
        import { getDatabase, ref, get, set, update, push, onValue } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

        // â˜…â˜…â˜… Firebase Config (ë³¸ì¸ í‚¤ ì…ë ¥) â˜…â˜…â˜…
        const firebaseConfig = {
  apiKey: "AIzaSyCMtMnUbfeeLTSFZJuRhDkv5xoCi2ioS6M",
  authDomain: "fatewalkers-29335.firebaseapp.com",
  databaseURL: "https://fatewalkers-29335-default-rtdb.firebaseio.com",
  projectId: "fatewalkers-29335",
  storageBucket: "fatewalkers-29335.firebasestorage.app",
  messagingSenderId: "343677807456",
  appId: "1:343677807456:web:c2b4a7bde3b9284b5c8c05",
  measurementId: "G-RVRS4BGZD1"
};

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // ==========================================
        // [ë°ì´í„°] ìŠ¤í‚¬ ë° íŒ¨ì‹œë¸Œ
        // ==========================================
        const DB = {
            SKILLS: {
                SLASH: { name: "ë² ê¸°", power: 25, range: 3, cooldown: 0, cost: 0, desc: "ì‚¬ê±°ë¦¬ 3ì¹¸, ë°ë¯¸ì§€ 25" },
                UPPER_SLASH: { name: "ìƒë‹¨ ë² ê¸°", power: 50, range: 2, cooldown: 3, cost: 0, desc: "ê°•ë ¥í•œ ì¼ê²© (ì¿¨íƒ€ì„ 3)" },
                GUARD: { name: "ê°€ë“œ", type: "buff", cooldown: 2, cost: 0, effect: "guard", desc: "ë‹¤ìŒ í”¼í•´ 30% ê²½ê°" },
                SHIELD_THROW: { name: "ë°©íŒ¨ ë˜ì§€ê¸°", power: 10, range: 4, triggerReAction: true, isUltimate: true, cost: 0, desc: "[ê¶ê·¹ê¸°] 1íšŒìš©. ì‚¬ìš© í›„ ì¬í–‰ë™." },
                MAGIC_MISSILE: { name: "ë§¤ì§ë¯¸ì‚¬ì¼", power: 20, range: 5, cost: 10, cooldown: 0, desc: "MP 10 ì†Œëª¨" },
                FIREBALL: { name: "íŒŒì´ì–´ë³¼", power: 30, range: 5, cost: 20, cooldown: 2, desc: "í™”ì—¼êµ¬ (MP 20)" },
                ICE_SPEAR: { name: "ì•„ì´ìŠ¤ ìŠ¤í”¼ì–´", power: 35, range: 4, cost: 20, cooldown: 2, desc: "ì–¼ìŒì°½ (MP 20)" },
                INFERNITY: { name: "ì¸í˜ë¥´ë‹ˆí‹°", power: 110, range: 8, cost: 100, cooldown: 5, isUltimate: true, disablePassive: 1, desc: "[ê¶ê·¹ê¸°] MP 100, íŒ¨ì‹œë¸Œ ë´‰ì¸" },
                DIAGONAL_SLASH: { name: "ì‚¬ì„ ë² ê¸°", power: 25, range: 2, cooldown: 0, cost: 0, extraMove: 3, desc: "ê³µê²© í›„ 3ì¹¸ ì´ë™" },
                STEALTH: { name: "ì€ì‹ ", type: "buff", range: 0, cooldown: 4, cost: 0, triggerReAction: true, effect: "stealth", desc: "ì€ì‹ (ì´ë™+1) & ì¬í–‰ë™" },
                KUNAI_THROW: { name: "ì¿ ë‚˜ì´ ë˜ì§€ê¸°", power: 25, range: 4, cooldown: 0, cost: 0, extraMove: 3, desc: "ì›ê±°ë¦¬ ê²¬ì œ" },
                BACKSTAB: { name: "ë°°í›„ë…¸ë¦¬ê¸°", power: 60, range: 6, cooldown: 0, cost: 0, isUltimate: true, reqStealth: true, teleportBehind: true, extraMove: 1, desc: "[ê¶ê·¹ê¸°] ì€ì‹  í•„ìˆ˜. ì  ë°°í›„ ì´ë™" },
                SNIPE: { name: "ì €ê²©", power: 20, range: 6, minRange: 4, cooldown: 0, cost: 0, desc: "ì‚¬ê±°ë¦¬ 4-6. ì¡°ì¤€ ì‹œ ê°•í™”" },
                AIM: { name: "ì¡°ì¤€", type: "buff", range: 0, cooldown: 0, cost: 0, triggerReAction: true, effect: "aim", desc: "ì´ë™ë¶ˆê°€, ì €ê²© ê°•í™”, ì¬í–‰ë™" },
                BACKSTEP: { name: "ë°±ìŠ¤í…", power: 0, range: 0, cooldown: 2, cost: 0, triggerReAction: true, effect: "backstep", desc: "ë’¤ë¡œ 2ì¹¸ ì´ë™ & ì¬í–‰ë™" },
                HEADSHOT: { name: "í—¤ë“œìƒ·", power: 70, range: 7, minRange: 5, cooldown: 6, cost: 0, isUltimate: true, chargeTurn: 1, desc: "[ê¶ê·¹ê¸°] 1í„´ ì°¨ì§• í›„ ë°œì‚¬" },
                DAGGER_STAB: { name: "ë‹¨ê²€ ì°Œë¥´ê¸°", power: 20, range: 2, cooldown: 0, cost: 0, desc: "ê¸°ë³¸ ê³µê²©" },
                PATH_DETECT: { name: "ê²½ë¡œ íƒì§€", type: "buff", range: 0, cooldown: 2, cost: 0, effect: "path_detect", desc: "3ë°°ìˆ˜:ê¸°ìŠµ3ë°° / 2ë°°ìˆ˜:ë‹¨ê²€+10" },
                PATH_SET: { name: "ê²½ë¡œ ì„¤ì •", type: "buff", range: 0, cooldown: 4, cost: 0, triggerReAction: true, effect: "path_set", desc: "ê±°ë¦¬10ì´ìƒ ì‹œ ì´ë™+7 & ì¬í–‰ë™" },
                CROSSBOW_SURGE: { name: "ì„ê¶ ì‡„ë„", power: 0, range: 5, cooldown: 4, cost: 0, isUltimate: true, desc: "[ê¶ê·¹ê¸°] í™”ì‚´x10 ë°ë¯¸ì§€" }
            },
            PASSIVES: {
                KNIGHT_SHIELD: { name: "ê¸°ì‚¬ì˜ ë°©íŒ¨", desc: "30%í™•ë¥ ë¡œ ë°ë¯¸ì§€ 20% ê²½ê°" },
                MANA_MASTER: { name: "ë§ˆë‚˜ì˜ ì£¼ì¸", desc: "ë§¤ í„´ MP 30 íšŒë³µ" },
                STEALTH_ART: { name: "ì€ì‹ ìˆ ", desc: "ì€ì‹  ì‹œ ì´ë™ë ¥ +1" },
                CRITICAL_HIT: { name: "í¬ë¦¬í‹°ì»¬ íˆíŠ¸", desc: "5% í™•ë¥ ë¡œ 1.5ë°° ë°ë¯¸ì§€" },
                PATHFINDER_KIT: { name: "íŒ¨ìŠ¤íŒŒì¸ë” í‚¤íŠ¸", desc: "ê¸°ìŠµ(11ì¹¸ì´ìƒ 2ë°°), 4ì¹¸ì´ë™ë§ˆë‹¤ í™”ì‚´+1" }
            },
            CHARACTERS: {
                KNIGHT: { name: "ê¸°ì‚¬", hp: 120, mp: 0, move: [3, 4], skills: ["SLASH", "UPPER_SLASH", "GUARD", "SHIELD_THROW"], passive: "KNIGHT_SHIELD", color: '#C0C0C0', desc: "ë†’ì€ ì²´ë ¥ê³¼ ë°©ì–´ë ¥ (íƒ±ì»¤)" },
                MAGE: { name: "ë§ˆë²•ì‚¬", hp: 100, mp: 100, move: [2, 4], skills: ["MAGIC_MISSILE", "FIREBALL", "ICE_SPEAR", "INFERNITY"], passive: "MANA_MASTER", color: '#9C27B0', desc: "ê°•ë ¥í•œ ë§ˆë²• ê³µê²© (ëˆ„ì»¤)" },
                NINJA: { name: "ë‹Œì", hp: 85, mp: 0, move: [4, 5], skills: ["DIAGONAL_SLASH", "STEALTH", "KUNAI_THROW", "BACKSTAB"], passive: "STEALTH_ART", color: '#333333', desc: "ì€ì‹ ê³¼ ì•”ì‚´ (ì•”ì‚´ì)" },
                BOW_MASTER: { name: "ë³´ìš° ë§ˆìŠ¤í„°", hp: 100, mp: 0, move: [3, 4], skills: ["SNIPE", "AIM", "BACKSTEP", "HEADSHOT"], passive: "CRITICAL_HIT", color: '#228B22', desc: "ì´ˆì¥ê±°ë¦¬ ì €ê²© (ìŠ¤ë‚˜ì´í¼)" },
                PATHFINDER: { name: "íŒ¨ìŠ¤íŒŒì¸ë”", hp: 70, mp: 0, move: [4, 7], skills: ["DAGGER_STAB", "PATH_DETECT", "PATH_SET", "CROSSBOW_SURGE"], passive: "PATHFINDER_KIT", color: '#FF4500', desc: "ì´ë™ ê±°ë¦¬ì— ë¹„ë¡€í•´ ê°•í•´ì§€ëŠ” ê¸°ë™í˜• ì‚¬ìˆ˜ (ë ˆì¸ì €)" }
            }
        };

        const PIXEL_DATA = {
            knight: { colors: {'s':'#C0C0C0','f':'#FFCC99','r':'#FF0000','b':'#4169E1'}, data: ["  ssss  "," ssrrss "," ssssss ","  ffff  ","  bbbb  "," ggssgg ","  s  s  "] },
            mage: { colors: {'p':'#800080','f':'#FFCC99','y':'#FFD700'}, data: ["  pppp  "," pppppp ","  ffff  ","  pppp  "," yppppppy","  p  p  "] },
            ninja: { colors: {'k':'#1a1a1a','r':'#8b0000','s':'#fff'}, data: ["  kkkk  "," kkkkkk "," kskksk ","  ffff  ","  kkkk  "," krrkkr ","  k  k  "] },
            bowmaster: { colors: {'g':'#2E7D32','b':'#8B4513','f':'#FFCC99'}, data: ["  gggg  "," ggggb b","  ffff  ","  gggg  "," bgggggb","  g  g  "] },
            pathfinder: { colors: {'o':'#FF4500','b':'#444','f':'#FFCC99'}, data: ["  oooo  "," oooooo ","  ffff  ","  bbbb  "," obbbbo ","  b  b  "] }
        };

        let myRole = null, currentRoomId = null, isMyTurn = false;
        let selectedCharKey = null, game = null;
        let mapData = [];
        const GRID_W = 11, GRID_H = 7, TILE_SIZE = 60;
        const SCREEN_W = 800, SCREEN_H = 800;
        const OFFSET_X = (SCREEN_W - (GRID_W * TILE_SIZE)) / 2; 
        const OFFSET_Y = (SCREEN_H - (GRID_H * TILE_SIZE)) / 2;

        let playerUnit, enemyUnit, hudText, descText, actionMenu;
        let gameState = 0; // 0:IDLE, 1:MOVE_SELECT, 2:ACTION_WAIT, 3:TARGET_SELECT, 4:BUSY
        let validMoves = [], highlights = [];
        let selectedSkill = null;

        function pixelToGrid(px, py) { return { x: Math.floor((px - OFFSET_X) / TILE_SIZE), y: Math.floor((py - OFFSET_Y) / TILE_SIZE) }; }
        function gridToPixel(gx, gy) { return { x: OFFSET_X + (gx * TILE_SIZE) + (TILE_SIZE / 2), y: OFFSET_Y + (gy * TILE_SIZE) + (TILE_SIZE / 2) }; }
        function toServer(lx, ly) { return myRole === 'p2' ? { x: (GRID_W - 1) - lx, y: (GRID_H - 1) - ly } : { x: lx, y: ly }; }
        function toLocal(sx, sy) { return myRole === 'p2' ? { x: (GRID_W - 1) - sx, y: (GRID_H - 1) - sy } : { x: sx, y: sy }; }

        document.getElementById('find-match-btn').onclick = () => {
            const btn = document.getElementById('find-match-btn');
            btn.disabled = true; btn.innerText = "ë§¤ì¹­ ì¤‘...";
            get(ref(db, 'rooms')).then((snap) => {
                const rooms = snap.val(); let found = null;
                if (rooms) for (let id in rooms) if (rooms[id].status === 'waiting') { found = id; break; }
                if (found) joinRoom(found); else createRoom();
            }).catch(e => { console.error(e); alert("DB ì—°ê²° ì‹¤íŒ¨!"); btn.disabled=false; });
        };

        function createRoom() {
            const newRef = push(ref(db, 'rooms'));
            currentRoomId = newRef.key; myRole = 'p1';
            const map = generateMap();
            set(newRef, { status: 'waiting', turn: 'p1', map: map, p1Ready: false, p2Ready: false });
            onValue(newRef, (s) => { if (s.val()?.status === 'selecting') onMatchFound(); });
        }

        function joinRoom(id) {
            currentRoomId = id; myRole = 'p2';
            update(ref(db, `rooms/${id}`), { status: 'selecting' });
            onMatchFound();
        }

        function onMatchFound() {
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('char-select-screen').style.display = 'flex';
            renderCharSelect();
        }

        function renderCharSelect() {
            const grid = document.getElementById('char-grid');
            grid.innerHTML = '';
            const infoBox = document.getElementById('char-info-box');
            Object.keys(DB.CHARACTERS).forEach(k => {
                const c = DB.CHARACTERS[k];
                const artKey = k.toLowerCase().replace('master', 'master');
                const iconData = PIXEL_DATA[artKey] || PIXEL_DATA['knight'];
                const iconUrl = drawIcon(iconData.data, iconData.colors);
                const el = document.createElement('div');
                el.style.cssText = `width:100px; height:120px; background:${c.color}; border:2px solid #fff; cursor:pointer; display:flex; flex-direction:column; align-items:center; justify-content:center; box-shadow: 0 0 10px rgba(0,0,0,0.5);`;
                el.innerHTML = `<img src="${iconUrl}" style="width:64px; height:64px; image-rendering:pixelated; margin-bottom:5px;"><b>${c.name}</b>`;
                el.onmouseenter = () => {
                    let skillHtml = `<div class='skill-list'>`;
                    c.skills.forEach(sid => { const s = DB.SKILLS[sid]; skillHtml += `<div class='skill-item'><span class='skill-name'>${s.name}</span><br><span style='font-size:0.8rem; color:#bbb;'>${s.desc}</span></div>`; });
                    skillHtml += `</div>`;
                    const passive = DB.PASSIVES[c.passive];
                    infoBox.innerHTML = `<div class='info-title' style='color:${c.color}'>${c.name}</div><div class='info-desc'>${c.desc}</div><div><b>ì´ë™:</b> ${c.move[0]}~${c.move[1]} / <b>HP:</b> ${c.hp}</div><div class='passive-item'>[íŒ¨ì‹œë¸Œ] ${passive.name}: ${passive.desc}</div><br><b>[ë³´ìœ  ìŠ¤í‚¬]</b> ${skillHtml}`;
                };
                el.onclick = () => {
                    Array.from(grid.children).forEach(b => b.style.border = "2px solid #fff");
                    el.style.border = "4px solid yellow";
                    selectedCharKey = k;
                    update(ref(db, `rooms/${currentRoomId}`), { [`${myRole}Char`]: k });
                    document.getElementById('lock-in-btn').disabled = false;
                };
                grid.appendChild(el);
            });
            const lockBtn = document.getElementById('lock-in-btn');
            const newLockBtn = lockBtn.cloneNode(true);
            lockBtn.parentNode.replaceChild(newLockBtn, lockBtn);
            newLockBtn.onclick = () => {
                update(ref(db, `rooms/${currentRoomId}`), { [`${myRole}Ready`]: true });
                newLockBtn.disabled = true; newLockBtn.innerText = "ëŒ€ê¸° ì¤‘...";
            };
        }

        setInterval(() => {
            if (!currentRoomId) return;
            get(ref(db, `rooms/${currentRoomId}`)).then((snap) => {
                const d = snap.val(); if (!d) return;
                if (d.p1Ready && d.p2Ready && d.status !== 'playing' && d.map) {
                    window.selectedChars = { p1: d.p1Char, p2: d.p2Char };
                    mapData = d.map;
                    if (myRole === 'p1') update(ref(db, `rooms/${currentRoomId}`), { status: 'playing' });
                    startGame();
                } else if (d.status === 'playing' && !game && d.map) {
                    window.selectedChars = { p1: d.p1Char, p2: d.p2Char };
                    mapData = d.map;
                    startGame();
                }
            });
        }, 1500);

        function startGame() {
            if(game) return;
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('char-select-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            game = new Phaser.Game(config);
        }

        class Unit {
            constructor(scene, data, lx, ly, isMe) {
                this.scene = scene;
                this.name = data.name; this.maxHp = data.hp; this.hp = data.hp; 
                this.mp = 0; this.maxMp = data.mp || 0;
                this.lx = lx; this.ly = ly; this.isMe = isMe;
                this.prevX = lx; this.prevY = ly;
                
                this.skills = data.skills.map(k => ({...DB.SKILLS[k], id: k}));
                this.passive = data.passive ? DB.PASSIVES[data.passive] : null;
                this.moveRange = data.move; this.cooldowns = {}; 
                
                // íŠ¹ìˆ˜ ìƒíƒœ
                this.guardActive = false; this.aimActive = false; 
                this.stealthActive = false; this.pathDetectActive = false;
                this.movedDistance = 0; this.arrows = 0;
                
                const pos = gridToPixel(lx, ly);
                let artKey = data.name === "ë³´ìš° ë§ˆìŠ¤í„°" ? "bowmaster" : data.name.toLowerCase();
                if(!PIXEL_DATA[artKey]) artKey = "knight";

                this.sprite = scene.add.sprite(pos.x, pos.y, artKey + '_art').setScale(1.5).setDepth(10);
                if (!isMe) this.sprite.setTint(0xff8888);
                this.hpText = scene.add.text(pos.x, pos.y - 35, `${this.hp}`, { fontSize: '14px', fontStyle: 'bold' }).setOrigin(0.5).setDepth(11);
                this.arrowText = scene.add.text(pos.x, pos.y - 50, "", { fontSize: '12px', fill:'#ff0' }).setOrigin(0.5).setDepth(11);
            }

            updatePos(lx, ly) {
                // ì´ë™ ì‹œ íŒ¨ìŠ¤íŒŒì¸ë” í™”ì‚´ íšë“ ë¡œì§
                const dist = Math.abs(this.lx - lx) + Math.abs(this.ly - ly);
                if(this.isMe && this.name === "íŒ¨ìŠ¤íŒŒì¸ë”") {
                    this.movedDistance += dist;
                    const gained = Math.floor(this.movedDistance / 4);
                    if(gained > 0) {
                        this.arrows += gained;
                        this.movedDistance %= 4; // ë‚¨ì€ ê±°ë¦¬ ìœ ì§€
                        this.arrowText.setText(`ğŸ¹${this.arrows}`);
                    }
                }

                this.lx = lx; this.ly = ly;
                const pos = gridToPixel(lx, ly);
                this.sprite.x = pos.x; this.sprite.y = pos.y;
                this.hpText.x = pos.x; this.hpText.y = pos.y - 35;
                this.arrowText.x = pos.x; this.arrowText.y = pos.y - 50;
            }
            savePos() { this.prevX = this.lx; this.prevY = this.ly; }
            revertPos() { this.updatePos(this.prevX, this.prevY); }
            takeDamage(d) { this.hp -= d; if(this.hp<0)this.hp=0; this.hpText.setText(`${this.hp}`); return this.hp <= 0; }
        }

        const config = {
            type: Phaser.AUTO, parent: 'game-container', width: SCREEN_W, height: SCREEN_H,
            backgroundColor: '#1a1a1a', scene: { preload: preload, create: create }
        };

        function preload() {
            const createArt = (key, colors, pixels) => {
                const canvas = this.textures.createCanvas(key, 32, 32);
                const ctx = canvas.context;
                const size = 32 / pixels.length;
                for(let y=0; y<pixels.length; y++) for(let x=0; x<pixels[y].length; x++) {
                    if(pixels[y][x] !== ' ') { ctx.fillStyle = colors[pixels[y][x]]; ctx.fillRect(x*size, y*size, size, size); }
                }
                canvas.refresh();
            };
            Object.keys(PIXEL_DATA).forEach(k => createArt(k+'_art', PIXEL_DATA[k].colors, PIXEL_DATA[k].data));
        }

        function create() {
            if (!mapData || mapData.length === 0) return;

            // ë§µ ê·¸ë¦¬ê¸°
            for (let x = 0; x < GRID_W; x++) for (let y = 0; y < GRID_H; y++) {
                const sPos = toServer(x, y);
                const cell = (mapData[sPos.x]) ? mapData[sPos.x][sPos.y] : null;
                const type = cell ? cell.type : 'Grass';
                let color = type === 'Water' ? 0x1a4a7a : type === 'Mountain' ? 0x4a4a4a : type === 'Sand' ? 0x8a7a4a : 0x3d5e3a;
                const pos = gridToPixel(x, y);
                this.add.rectangle(pos.x, pos.y, TILE_SIZE-2, TILE_SIZE-2, color).setStrokeStyle(1, 0x000, 0.5);
            }

            const myK = myRole === 'p1' ? window.selectedChars.p1 : window.selectedChars.p2;
            const enK = myRole === 'p1' ? window.selectedChars.p2 : window.selectedChars.p1;
            playerUnit = new Unit(this, DB.CHARACTERS[myK], 5, 6, true);
            enemyUnit = new Unit(this, DB.CHARACTERS[enK], 5, 0, false);

            hudText = this.add.text(400, 30, "", { fontSize: '18px', align: 'center' }).setOrigin(0.5);
            descText = this.add.text(400, 750, "", { fontSize: '16px', align: 'center' }).setOrigin(0.5);
            actionMenu = this.add.container(680, 150).setDepth(100);

            this.input.on('pointerdown', (pointer) => {
                const gp = pixelToGrid(pointer.x, pointer.y);
                if (gp.x >= 0 && gp.x < GRID_W && gp.y >= 0 && gp.y < GRID_H) processClick(gp.x, gp.y);
            });

            updateHUD();
            setupSync();
        }

        function processClick(x, y) {
            if (!isMyTurn || gameState === 4) return;

            // 1. ì´ë™ ëª¨ë“œ
            if (gameState === 0 && x === playerUnit.lx && y === playerUnit.ly) {
                playerUnit.savePos();
                calculateMoveRange();
                gameState = 1; 
                descText.setText("ì´ë™í•  ê³³ì„ ì„ íƒí•˜ì„¸ìš”.");
                return;
            }

            if (gameState === 1) {
                if (validMoves.some(p => p.x === x && p.y === y)) {
                    playerUnit.updatePos(x, y);
                    clearHighlights();
                    gameState = 2; // ACTION_WAIT
                    openActionMenu();
                    descText.setText("í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”.");
                } else {
                    gameState = 0; clearHighlights(); descText.setText("ì´ë™ ì·¨ì†Œë¨.");
                }
                return;
            }

            // 2. ìŠ¤í‚¬ íƒ€ê²ŸíŒ… (ì¤‘ìš”!)
            if (gameState === 3) {
                // ë²”ìœ„ ë‚´ í´ë¦­ì¸ì§€ í™•ì¸
                if (isHighlighted(x, y)) {
                    // ìœ ë‹›ì´ ìˆëŠ” ê²½ìš°
                    if (x === enemyUnit.lx && y === enemyUnit.ly) {
                        executeAction(selectedSkill, enemyUnit);
                    } else if (x === playerUnit.lx && y === playerUnit.ly) {
                        executeAction(selectedSkill, playerUnit);
                    } else {
                        // ë•… í´ë¦­ (ì´ë™ê¸° ë“±, í˜„ì¬ëŠ” ì¼ë‹¨ ë§‰ìŒ)
                        descText.setText("ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤. ìœ ë‹›ì„ ì„ íƒí•˜ì„¸ìš”.");
                    }
                } else {
                    descText.setText("ì‚¬ê±°ë¦¬ ë°–ì…ë‹ˆë‹¤. ë¹¨ê°„ ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”.");
                }
            }
        }

        function calculateMoveRange() {
            validMoves = []; clearHighlights();
            let bonus = (playerUnit.passive?.name === 'ì€ì‹ ìˆ ' && playerUnit.stealthActive) ? 1 : 0;
            const r = Phaser.Math.Between(playerUnit.moveRange[0], playerUnit.moveRange[1]) + bonus; 
            
            for (let x = 0; x < GRID_W; x++) for (let y = 0; y < GRID_H; y++) {
                const dist = Math.abs(x - playerUnit.lx) + Math.abs(y - playerUnit.ly);
                const sPos = toServer(x, y);
                const cell = mapData[sPos.x] ? mapData[sPos.x][sPos.y] : null;
                
                if (dist === 0 || dist > r) continue;
                if (cell && (cell.type === 'Mountain' || cell.type === 'Water')) continue;
                if (x === enemyUnit.lx && y === enemyUnit.ly) continue;

                validMoves.push({x, y});
                const pos = gridToPixel(x, y);
                highlights.push(game.scene.scenes[0].add.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE, 0x0000ff, 0.4).setDepth(5));
            }
        }

        function openActionMenu() {
            actionMenu.removeAll(true);
            const scene = game.scene.scenes[0];
            actionMenu.add(scene.add.rectangle(0, 150, 140, 350, 0x222222, 0.9));

            let y = 0;
            playerUnit.skills.forEach(skill => {
                const cd = playerUnit.cooldowns[skill.id] || 0;
                const disabled = cd > 0;
                const btn = scene.add.rectangle(0, y, 120, 40, disabled ? 0x555 : 0x880000).setInteractive();
                const txt = scene.add.text(0, y, skill.name + (cd?`(${cd})`:""), {fontSize:'14px'}).setOrigin(0.5);
                
                if (!disabled) {
                    btn.on('pointerdown', () => {
                        selectedSkill = skill;
                        if (skill.range > 0) {
                            // íƒ€ê²ŸíŒ… ëª¨ë“œ ì§„ì…
                            gameState = 3; 
                            clearHighlights();
                            showTargetRange(playerUnit.lx, playerUnit.ly, skill.range);
                            descText.setText(`[${skill.name}] ëŒ€ìƒì„ ì„ íƒí•˜ì„¸ìš” (ë¹¨ê°„ ì¹¸)`);
                            actionMenu.removeAll(true);
                        } else {
                            // ì¦‰ì‹œ ì‹œì „ (ë²„í”„ ë“±)
                            executeAction(skill, playerUnit);
                        }
                    });
                }
                actionMenu.add(btn); actionMenu.add(txt); y += 50;
            });

            // ëŒ€ê¸° & ì·¨ì†Œ
            const wBtn = scene.add.rectangle(0, y, 120, 40, 0x000088).setInteractive();
            wBtn.on('pointerdown', () => executeAction({id:'WAIT'}, null));
            actionMenu.add(wBtn); actionMenu.add(scene.add.text(0, y++, "ëŒ€ê¸°", {fontSize:'14px'}).setOrigin(0.5));
            
            y += 50;
            const cBtn = scene.add.rectangle(0, y, 120, 40, 0x444).setInteractive();
            cBtn.on('pointerdown', () => { playerUnit.revertPos(); gameState=0; actionMenu.removeAll(true); clearHighlights(); descText.setText("ì·¨ì†Œë¨"); });
            actionMenu.add(cBtn); actionMenu.add(scene.add.text(0, y, "ì·¨ì†Œ", {fontSize:'14px'}).setOrigin(0.5));
        }

        function showTargetRange(sx, sy, r) {
            for (let x = 0; x < GRID_W; x++) for (let y = 0; y < GRID_H; y++) {
                if (Math.abs(x - sx) + Math.abs(y - sy) <= r) {
                    const pos = gridToPixel(x, y);
                    highlights.push(game.scene.scenes[0].add.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE, 0xff0000, 0.4).setDepth(5));
                }
            }
        }

        // â˜…â˜…â˜… ë°ë¯¸ì§€ & íŒ¨ì‹œë¸Œ í†µí•© ê³„ì‚° â˜…â˜…â˜…
        function calculateDamage(skill, attacker, defender) {
            let dmg = skill.power || 0;
            
            // 1. ê³µê²©ì ë³´ì •
            if(attacker.name === "ë³´ìš° ë§ˆìŠ¤í„°") {
                if(attacker.aimActive && skill.name === "ì €ê²©") { dmg += 20; attacker.aimActive = false; }
                if(attacker.passive?.name === "í¬ë¦¬í‹°ì»¬ íˆíŠ¸" && Math.random() < 0.05) { dmg *= 1.5; descText.setText("í¬ë¦¬í‹°ì»¬!"); }
                if(skill.name === "í—¤ë“œìƒ·") dmg *= 1.5; 
            }
            if(attacker.name === "íŒ¨ìŠ¤íŒŒì¸ë”") {
                if(skill.name === "ì„ê¶ ì‡„ë„") dmg = (attacker.arrows || 0) * 10;
                if(attacker.movedDistance >= 11) { dmg *= 2; descText.setText("ê¸°ìŠµ ë°œë™! (2ë°°)"); }
                if(skill.name === "ë‹¨ê²€ ì°Œë¥´ê¸°" && attacker.pathDetectActive) dmg += 10;
            }

            // 2. ë°©ì–´ì ë³´ì •
            if(defender.guardActive) dmg *= 0.7;
            if(defender.passive?.name === "ê¸°ì‚¬ì˜ ë°©íŒ¨" && Math.random() < 0.3) { dmg *= 0.8; descText.setText("ê¸°ì‚¬ì˜ ë°©íŒ¨ ë°©ì–´!"); }

            return Math.floor(dmg);
        }

        function executeAction(skill, target) {
            gameState = 4; actionMenu.removeAll(true); clearHighlights();

            if (skill.cost > 0) playerUnit.mp -= skill.cost;

            // ê³µê²© ì²˜ë¦¬
            if (skill.power > 0 || skill.name === "ì„ê¶ ì‡„ë„") {
                if(target) {
                    const dmg = calculateDamage(skill, playerUnit, target);
                    target.takeDamage(dmg);
                    
                    // íŒ¨ìŠ¤íŒŒì¸ë” í™”ì‚´ ì†Œëª¨
                    if(skill.name === "ì„ê¶ ì‡„ë„") {
                        playerUnit.arrows = 0; playerUnit.arrowText.setText("ğŸ¹0");
                    }
                }
            }
            
            // ë²„í”„ ì²˜ë¦¬
            if (skill.effect === 'guard') playerUnit.guardActive = true;
            if (skill.effect === 'stealth') playerUnit.stealthActive = true;
            if (skill.effect === 'aim') playerUnit.aimActive = true;
            if (skill.effect === 'path_detect') playerUnit.pathDetectActive = true;

            // í…”ë ˆí¬íŠ¸ (ë‹Œì)
            if (skill.teleportBehind && target) {
                const ty = target.ly + (target.ly > playerUnit.ly ? 1 : -1);
                if (ty >= 0 && ty < GRID_H) playerUnit.updatePos(target.lx, ty);
            }

            updateHUD();

            // í„´ ì²˜ë¦¬
            if (skill.triggerReAction) {
                endTurnEffects(playerUnit);
                setTimeout(() => { gameState = 0; updateDB(false); }, 800);
            } else {
                setTimeout(() => updateDB(true), 500);
            }
        }

        function updateDB(endTurn) {
            const sPos = toServer(playerUnit.lx, playerUnit.ly);
            update(ref(db, `rooms/${currentRoomId}`), {
                [`${myRole}Unit`]: { x: sPos.x, y: sPos.y, hp: playerUnit.hp, mp: playerUnit.mp },
                turn: endTurn ? (myRole === 'p1' ? 'p2' : 'p1') : myRole
            });
        }

        function setupSync() {
            onValue(ref(db, `rooms/${currentRoomId}`), (snap) => {
                const d = snap.val(); if (!d) return;
                
                if (d.turn === myRole) {
                    isMyTurn = true; gameState = 0; descText.setText("ë‚˜ì˜ í„´!");
                    endTurnEffects(playerUnit);
                } else {
                    isMyTurn = false; descText.setText("ìƒëŒ€ë°©ì˜ í„´...");
                }

                const enRole = myRole === 'p1' ? 'p2' : 'p1';
                const enD = d[`${enRole}Unit`];
                if (enD) {
                    const lPos = toLocal(enD.x, enD.y);
                    enemyUnit.updatePos(lPos.x, lPos.y);
                    enemyUnit.hp = enD.hp; enemyUnit.mp = enD.mp;
                    enemyUnit.hpText.setText(`${enD.hp}`);
                    updateHUD();
                }
            });
        }

        function endTurnEffects(u) {
            for(let k in u.cooldowns) if(u.cooldowns[k]>0) u.cooldowns[k]--;
            if(u.passive?.name==="ë§ˆë‚˜ì˜ ì£¼ì¸") u.mp = Math.min(u.maxMp, u.mp+30);
            u.movedDistance = 0; // ê±°ë¦¬ ì´ˆê¸°í™”
            u.guardActive = false; // ë°©ì–´ í•´ì œ
        }

        function updateHUD() {
            if(!playerUnit || !enemyUnit) return;
            hudText.setText(`[ë‚˜] HP:${playerUnit.hp} MP:${playerUnit.mp}  vs  [ì ] HP:${enemyUnit.hp} MP:${enemyUnit.mp}`);
        }

        function isHighlighted(x, y) { return highlights.some(h => {
             // í•˜ì´ë¼ì´íŠ¸ ì‚¬ê°í˜•ì˜ ì¢Œí‘œë¥¼ ê·¸ë¦¬ë“œ ì¢Œí‘œë¡œ ë³€í™˜í•´ ë¹„êµ
             const gp = pixelToGrid(h.x, h.y);
             return gp.x === x && gp.y === y;
        }); }
        
        function clearHighlights() { highlights.forEach(h => h.destroy()); highlights = []; }
        function drawIcon(pixels, colors) {
            const c = document.createElement('canvas'); c.width=32; c.height=32; const ctx=c.getContext('2d');
            const s=32/pixels.length;
            pixels.forEach((row, y) => [...row].forEach((col, x) => {
                if(col!==' ') { ctx.fillStyle=colors[col]; ctx.fillRect(x*s, y*s, s, s); }
            }));
            return c.toDataURL();
        }
        function generateMap() {
            let m = [];
            for(let x=0; x<GRID_W; x++) {
                m[x] = [];
                for(let y=0; y<GRID_H; y++) {
                    let t = 'Grass';
                    if(x!==5 && Math.random()<0.3) t=['Water','Mountain','Sand'][Math.floor(Math.random()*3)];
                    m[x][y] = {type: t};
                }
            }
            return m;
        }
    </script>
</body>
</html>
